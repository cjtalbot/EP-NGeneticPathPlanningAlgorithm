//  Christine Talbot
//  CS 8151
//  Project
//  Due 4/25/13
// 
//  Description :
//  		This object is used for the paths generated by the genetic algorithm
//
//  Method Summary :
//			this.getLength()
//				Returns the length of the entire path
//			this.updNode(which, x, y)
//				Updates a single node within the path and recalculates quality and viability
//			this.better(path2)
//				Compares this path with path2, returning true if this one is better than path2
//			this.checkNodes()
//				Calculates quality and viability of the entire path
//			this.draw(c,globgs)
//				Draws the path in black if not viable (collision), or in orange if viable
//
//  --------------------------------------------------------------------------------------

// Path related GLOBALS
var PATHCOUNT = 0;

//  --------------------------------------------------------------------------------------
//  Name: Path
//
//	Description:
//		Path Object Initialization
//	
//	Inputs:
//		num - number of nodes to include in the path (minus the start/end nodes)
//		startnode - starting point for the path (robot location)
//		goalnode - ending point for the path (goal location)
//
//	Outputs:
//		path - new object
//
//  --------------------------------------------------------------------------------------
function Path(num, startnode, goalnode) {
	this.name = PATHCOUNT;
	PATHCOUNT++;
	this.numnodes = num +2;
	this.nodes = [];
	this.nodes.push(startnode);
	for (var i=0; i<this.numnodes-2; i++) {
		this.nodes.push(new Node(Math.floor(Math.random()*800), Math.floor(Math.random()*500)));
	}
	this.nodes.push(goalnode);
	this.quality = 0; // default goodness of this path
	this.pathlength = 0;
	this.best = false; // so can use this as a reference later
	this.curvature = [];
	this.clearance = [];
	this.penetration = [];
	this.checkNodes = checkNodes;
	this.viable = true;

//  --------------------------------------------------------------------------------------
//  Name: getLength
//
//	Description:
//		Returns the length of the entire path
//	
//	Inputs:
//		none
//
//	Outputs:
//		length - length of the entire path
//
//  --------------------------------------------------------------------------------------
	this.getLength = getLength;	
	function getLength() {
		// returns the length of the path - for shortest path info
		var len = 0;
		for (var i=1; i<this.numnodes; i++) {
			len = len + getdist(this.nodes[i-1].x, this.nodes[i-1].y, this.nodes[i].x, this.nodes[i].y);
		}
		return len;
	}
	
	this.checkNodes(); // whether any obstacles for the path or not

	allpaths.push(this);

//  --------------------------------------------------------------------------------------
//  Name: updNode
//
//	Description:
//		Updates a single node within the path and recalculates quality and viability
//	
//	Inputs:
//		which - index of node to be updated
//		x - x coordinate to update to
//		y - y coordinate to update to
//
//	Outputs:
//		none
//
//  --------------------------------------------------------------------------------------
	this.updNode = updNode;
	function updNode(which, x, y) {
		if (which < this.numnodes) {
			this.nodes[which].x = x;
			this.nodes[which].y = y;
		}
		// reset variables!!!
		this.checkNodes();
	}
	
//  --------------------------------------------------------------------------------------
//  Name: better
//
//	Description:
//		Compares this path with path2, returning true if this one is better than path2
//			Viable paths are always better than non-viable paths
//			If both paths are viable or both paths are not viable, then quality determines
//			which is better
//	
//	Inputs:
//		path2 - path to compare with this path
//
//	Outputs:
//		boolean - true if this path is better than path2
//
//  --------------------------------------------------------------------------------------
	this.better = better; // returns true if this path is better or same as path2
	function better(path2) {
		if (this.viable == true && path2.viable == false) {
			return true;
		} else if (this.viable == false && path2.viable == true) {
			return false;
		} else if (this.quality <= path2.quality) {
			return true;
		} else {
			return false;
		}
	}

//  --------------------------------------------------------------------------------------
//  Name: checkNodes
//
//	Description:
//		Calculates quality and viability of the entire path
//			Checks every segment and every turn on the path for collision with every
//			obstacle.  If no collisions, then this paths' viable variable will be true,
//			else it will be false.  If not viable, penetration will reflect how far the
//			path crosses into an obstacle, if viable, clearance will reflect how far
//			the path is from the closest obstacle.  The quality of this path will reflect
//			length of the path + clearance + smoothness for viable paths, or length of
//			the path + penetration for non-viable paths.
//	
//	Inputs:
//		none
//
//	Outputs:
//		boolean - whether the path is viable (no collisions) = true or not = false
//
//  --------------------------------------------------------------------------------------
	function checkNodes() {
		this.pathlength = this.getLength();
		this.viable = true;
		var o1;
		var o2;
		var A;
		var B;
		var turnpt;
		// loop through all node segments in path and check against allobjects array for .checkIntersect -- if any say true, then return false!  Be sure to check node first, but then check along the segments too
		for (var i=0; i < this.nodes.length; i++) {
			// check if any intersections with this segment from i-1 to i
			for (var o=0; o < obstacles.length; o++) {
				if (i > 0) {
					var check = obstacles[o].checkIntersectRobotPath(this.nodes[i-1].x, this.nodes[i-1].y, this.nodes[i].x, this.nodes[i].y);
					
					// update vars
					if (check.crossed) {
						this.viable = false;
						this.penetration[i] = check.penetration; // penetration[0] won't exist
						this.clearance[i] = 0; // clearance[0] won't exist
					} else {
						this.clearance[i] = check.clearance;
						this.penetration[i] = 0;
					}
				} else {
					this.penetration[0] = 0;
					this.clearance[0] = Number.MAX_VALUE;
				}
				// check the rotation between the two segments for intersection - how? - will need to check for robot orientation to start position's angle before calling this func too!
				if (i == 0) {
					o1 = robot.center.o;
				} else {
					o1 = Math.atan2(this.nodes[i-1].y - this.nodes[i].y, this.nodes[i-1].x - this.nodes[i].x);
				}
				turnpt = this.nodes[i];
				if (i < this.nodes.length-1) {
					o2 = Math.atan2(this.nodes[i].y - this.nodes[i+1].y, this.nodes[i].x - this.nodes[i+1].x);
					A = {x: turnpt.x + (ROBOT_DIAG*Math.cos(o1+(Math.atan2(ROBOT_HEIGHT/ROBOT_DIAG, ROBOT_WIDTH/ROBOT_DIAG)))), y:turnpt.y + (ROBOT_DIAG*Math.sin(o1+(Math.atan2(ROBOT_HEIGHT/ROBOT_DIAG, ROBOT_WIDTH/ROBOT_DIAG))))};
					B = {x: turnpt.x + (ROBOT_DIAG*Math.cos(o2+(Math.atan2(ROBOT_HEIGHT/ROBOT_DIAG, ROBOT_WIDTH/ROBOT_DIAG)))), y:turnpt.y + (ROBOT_DIAG*Math.sin(o2+(Math.atan2(ROBOT_HEIGHT/ROBOT_DIAG, ROBOT_WIDTH/ROBOT_DIAG))))};
					var turncheck = obstacles[o].checkIntersectSegment(A.x, A.y, B.x, B.y);
					var Ddist = getdist(turnpt.x, turnpt.y, obstacles[o].center.x, obstacles[o].center.y);
					if (turncheck.crossed) {
						this.viable = false;
						// update penetration & clearance?
						if (turncheck.penetration > this.penetration[i]) {
							this.penetration[i] = turncheck.penetration;
						}
						this.clearance[i] = 0;
					} else {
						if (!(turncheck.closest.x == A.x && turncheck.closest.y == A.y) && !(turncheck.closest.x == B.x && turncheck.closest.y == B.y) && Ddist<=ROBOT_DIAG+obstacles[o].r) {
							this.viable = false;
							// update penetration & clearance?
							if (turncheck.penetration > this.penetration[i]) {
								this.penetration[i] = turncheck.penetration;
							}
							this.clearance[i] = 0;
						} else {
							if (this.viable) {
								// update clearance & penetration
								if (turncheck.clearance < this.clearance[i]) {
									this.clearance[i] = turncheck.clearance;
								}
								this.penetration[i] = 0;
							} else {
								// do nothing - keep prior values
							}
						}
					}
					
				} else {
					// at last node, so no need to check turns
				}
			}
			if (obstacles.length == 0) {
						// in case there aren't any obstacles:
						this.viable = true;
						this.penetration[i] = 0;
						this.clearance[i] = 0;
			}
			// now check for curvature using the angles between each segment
			if (i >= 2) {
				this.curvature[i] = (((this.nodes[i-1].x - this.nodes[i-2].x)*(this.nodes[i].x - this.nodes[i-1].x))+((this.nodes[i-1].y - this.nodes[i-2].y)*(this.nodes[i].y - this.nodes[i-1].y)))/(getdist(this.nodes[i-2].x, this.nodes[i-2].y, this.nodes[i-1].x, this.nodes[i-1].y)*getdist(this.nodes[i-1].x, this.nodes[i-1].y, this.nodes[i].x, this.nodes[i].y));
				if (this.curvature[i] < 0) {
					this.curvature[i] = this.curvature[i]+(2*Math.PI);
				} 
			}// curvature[0] and curvature[1] won't exist
		}
		// now check for curvature using the angles between each segment
		
		// also set the quality of this path here
		var temp;
		var clear;
		var curve;
		if (this.viable) {
			if (this.clearance[0] > this.clearance[1]) {
				clear = this.clearance[0];
			} else {
				clear = this.clearance[1];
			}
			curve = this.curvature[2];
			for (var m=2; m<this.clearance.length; m++) {
				if (this.clearance[m] > clear) {
					clear = this.clearance[m];
				}
				if (this.curvature[m] > curve) {
					curve = this.curvature[m];
				}
			}
			if (curve == undefined) {
				curve = 0;
			}
			this.quality = this.pathlength + curve + clear;// Math.max.apply(null,this.curvature)+Math.max.apply(null,this.clearance);
		} else {
			temp = 0;
			for (var j=0; j<this.penetration.length; j++) {
				temp = temp + this.penetration[j];
			}
			this.quality = this.pathlength + temp;//this.penetration.splice(0,1).reduce(function(previousValue, currentValue, index, array) { return previousValue + currentValue;}); // need to get a sum function!
		}
		
		return this.viable;
	}

//  --------------------------------------------------------------------------------------
//  Name: draw
//
//	Description:
//		Draws the path in black if not viable (collision), or in orange if viable
//	
//	Inputs:
//		c - canvas object
//		globgs - gamesoup canvas
//
//	Outputs:
//		none
//
//  --------------------------------------------------------------------------------------
	this.draw = function(c, globgs) {
		c.lineWidth = 1;
		if (this.viable ){
			c.strokeStyle = 'rgba(255, 100, 0, 1.0)';
		} else {
			c.strokeStyle = 'rgba(0,0,0, 1.0)';
		}

		for (var i=1; i < this.nodes.length; i++) {
			c.beginPath();
			c.moveTo(this.nodes[i-1].x, this.nodes[i-1].y);
			c.lineTo(this.nodes[i].x, this.nodes[i].y);
			c.closePath();
			c.stroke();
		}
	}
		
}
